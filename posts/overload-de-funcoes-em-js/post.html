<!--:::{
  "post_title": "Overload de fun√ß√µes em JavaScript",
  "post_description": "Overload √© a tenica de termos diferentes implementa√ß√µes para uma fun√ß√£o de mesmo nome. Vamos ver como implementar isso em JavaScript",
  "post_created_at": "Wed Jul 27 2022 00:17:53 GMT-0300 (Brasilia Standard Time)"
}:::-->

<style>img { max-width: 100%}</style>

<p>
  Function Overload √© a tecnica de manter varias fun√ß√µes com o mesmo nome mas diferentes implementa√ß√µes.
</p>

<p>
  Ela se comporta diferente dependendo de como vc chama. Em JS n√£o podemos ter fun√ß√µes com o mesmo nome: a ultima declara√ß√£o vai sobrep√¥r. 
</p>

<p>
  Ent√£o como fazer Overload em JS?
</p>

<p>
  Para que possamos fazer overload em JS n√≥s precisamos de umas coisas:
</p>

<ol>
  <li>
    Uniqueness: Uma unica fun√ß√£o com um nome unico no contexto, ou seja, vc s√≥ pode declarar uma fun√ß√£o.
  </li>

  <li>
    Introspection: Nossa fun√ß√£o deve ser capaz de analisar a si mesma e descobrir o que fazer.
  </li>
</ol>

<p>
  Bora l√°:
</p>

<p>
  Existem algumas maneiras de fazer isso, e eu vou mostrar algumas delas. No entanto todas baseiam-se numa mesma premissa: condicional via diferencia√ß√£o de argumentos.
</p>

<p>
  Nossa fun√ß√£o vai agir de forma diferente de acordo com o tipo e/ou numero de argumentos que passamos pra ela.
</p>

<p>
  Vamos fazer isso de forma escalar. Imagine a seguinte fun√ß√£o: vc passa dois parametros, ela junta os dois e retorna em formato string:
</p>

<pre>
  <code class="language-javascript">
    function concat(a, b) {
      return `${a} ${b}`;
    }
  </code>
</pre>

<p>
  Simples n√©?
</p>
  
<img src="./overload-1.png" alt="Imagem do c√≥digo acima">

<p>
  Mas temos um bug: se eu n√£o passar nenhum argumento ou passar apenas o primeiro ela me devolve `undefined` no meio da string. Sem problemas: vamos pre-inicializar os argumentos e adicionar um trim() no resultado:
</p>

<pre>
  <code class="language-javascript">
    function concat(a, b) {
      return `${a} ${b}`.trim();
    }
  </code>
</pre>

<p>
  Deboas...
</p>

<img src="./overload-2.png" alt="Imagem do c√≥digo acima">

<p>
  Agora imaginemos que precisamos refatorar nossa fun√ß√£o pra que ela seja capaz de concatenar um numero infinito de parametros. Sem problemas:
</p>

<pre>
  <code class="language-javascript">
    function concat(...args) {
      return args.join(' ').trim();
    }
  </code>
</pre>

<img src="./overload-3.png" alt="Imagem do c√≥digo acima">

<p>
  Mas a√≠ alguem faz isso: concat([ 'fizz', 'buzz' ]); e obtem como resultado isso: 'fizz,buzz'.
</p>

<p>
  A pessoa diz: poxa vem uns arrays do backend, eu queria poder passar um array para a concat direto tbm e ela se comportar normalmente.
</p>

<p>
  üåü Overload for the rescue üåü
</p>

<p>
  Nesse caso vamos fazer um overload da implementa√ß√£o da fun√ß√£o: quando receber um array como primeiro parametro fa√ßa x coisa de x maneira. As coisas ficar√£o um pouco teoricas:
</p>

<p>
  Nossa fun√ß√£o tem a seguinte assinatura at√© ent√£o:
</p>

<p>
  function concat(...args: string): string
</p>

<p>
  Quando dizemos que ela tbm pode ter um array como primeiro parametro, temos duas assinaturas para a mesma fun√ß√£o, porem o mesmo output:
</p>

<ol>
  <li>
    function concat(...args: string): string
  </li>

  <li>
    function concat(arg: string[]): string
  </li>
</ol>

<p>
  N√≥s fizemos um OVERLOAD e mexemos na Aridade da fun√ß√£o.
</p>

<p>
  Vc deve ta pensando: "overload NO QUE?". Aridade (arity) √© o numero de parametros (ou operandos) que uma fun√ß√£o leva. 
</p>

<p>
  Basicamente √© isso: nossa fun√ß√£o 1 tem aridade diferente da fun√ß√£o 2 porque sofreu overload, mas elas s√£o a "mesma" fun√ß√£o.
</p>

<p>
  T√°, mas como implementamos isso?
</p>

<p>
  Assim:
</p>

<pre>
  <code class="language-javascript">
    function concat(...args) {
      if (Array.isArray(args[0])) {
        return args[1].join(' ').trim();
      }
  
      return args.join(' ').trim();
    }
  </code>
</pre>

<p>
  O que fizemos na fun√ß√£o acima foi verificar se o primeiro parametro passado pra ela (args[0]) √© do tipo array (arity check), e se for assim retornamos o concat apenas desse array e ignoramos o resto (behavior change).
</p>

<p>
  E por isso temos um overload. Embora o output seja o mesmo, a assinatura e o comportamento (implementa√ß√£o) diferem na fun√ß√£o de mesmo nome. 
</p>

<p>
  No caso da nossa fun√ß√£o ela ainda ta meio dummy, ela repete o comportamento do output e reimplementa a logica. Podemos melhorar isso.
</p>

<p>
  Quando vc ta fazendo overload mas o output n√£o vai mudar, ao inves de criar ifs e diversos returns, pode apenas normalizar os parametros e chama a fun√ß√£o novamente de dentro dela mesma, evitando reimplementar a mesma logica dentro de ifs. Assim:
</p>

<pre>
  <code class="language-javascript">
    function concat(...args) {
      if (Array.isArray(args[0])) {
        return concat(...args[0]);
      }
    
      return args.join(' ').trim();
    }
  </code>
</pre>

<p>
  Temos o "Overloaded Behavior" esperado sem repeti√ß√£o de l√≥gica. O ...args[0] faz spread do array em forma de parametros pra mesma fun√ß√£o:
</p>

<img src="./overload-4.png" alt="Imagem para o c√≥digo acima">

<p>
  Mas a√≠ alguem chega e fala: Muito legal tudo isso mas eu queria que quando o primeiro e o segundo parametro fossem um numero a fun√ß√£o retornasse a soma e n√£o o str concat.
</p>

<p>
  E da√≠ vc manda a pessoa a merda, tira a camiseta e foge pras colinas correndo...
</p>

<p>
  Brincadeira. Vc Implementa. Novamente:
</p>

<p>
  üåü OVERLOAD TO THE RESCUE üåü
</p>

<p>
  Mas agora vc j√° tem mais experiencia e vai fazer isso da seguinte maneira:
</p>

<pre>
  <code class="language-javascript">
    function concat(...args) {
      if (Array.isArray(args[0])) {
        return concat(...args[0]);
      }
    
      if (typeof args[0] === 'number' && typeof args[1] === 'number') {
        return args[0] + args[1];
      }
    
      return args.join(' ');
    }
  </code>
</pre>

<p>
  O que fizemos no segundo if foi dizer o seguinte: Se o primeiro e o segundo parametro s√£o do tipo numerico, vc ignora tudo e devolve a soma dos dois. 
</p>

<p>
  Novamente: Function Overload. Diferentes implementa√ß√µes para diferentes aridades.
</p>

<img src="./overload-5.png" alt="Imagem para o c√≥digo acima">

<p>
  √â isso. Ap√≥s aprendermos overload, nossa fun√ß√£o terminou com 2 outputs e 3 assinaturas:
</p>

<ol>
  <li>
    function concat(...args: string): string
  </li>

  <li>
    function concat(arg: string[]): string
  </li>

  <li>
    function concat(a: number, b: number): number
  </li>
</ol>

<p>
  Exemplos meramente ilustrativos, claro. Bons estudos!
</p>