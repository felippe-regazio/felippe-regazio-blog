<!-- This is an automatically generated file, do not edit it directly -->
<!DOCTYPE html>
<html lang="en">
<head>
  <title>Frontend para Backenders | Conceitos necess√°rios</title>
  <meta charset="UTF-8">
  
  <!-- SEO -->
  <meta name="author" content="Felippe Regazio">
  <meta name="description" content="Ao longo da minha carreira eu percebi que muitos backs n√£o sabem como o front moderno funciona, e isso gera v√°rios problemas de arquitetura e v√°rias tretas de escopo nos apps.">
  <meta property="og:title" content="Frontend para Backenders | Conceitos necess√°rios">
  <meta property="og:description" content="Ao longo da minha carreira eu percebi que muitos backs n√£o sabem como o front moderno funciona, e isso gera v√°rios problemas de arquitetura e v√°rias tretas de escopo nos apps.">
  <meta property="og:site_name" content="Web Development & anything else">
  <meta property="og:url" content="https://felipperegazio.com/posts/frontend-para-backenders">
  <meta property="og:image" content="https://felipperegazio.com/card.jpg"/>
  <meta property="og:type" content="Website"/>
  <meta property="og:image:width" content="1200" />
  <meta property="og:image:height" content="627" />
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="Web Development & anything else">
  <meta name="twitter:creator" content="Felippe Regazio">
  <meta name="twitter:title" content="Frontend para Backenders | Conceitos necess√°rios">
  <meta name="twitter:description" content="Ao longo da minha carreira eu percebi que muitos backs n√£o sabem como o front moderno funciona, e isso gera v√°rios problemas de arquitetura e v√°rias tretas de escopo nos apps.">
  <meta name="twitter:image:src" content="https://felipperegazio.com/card.jpg">
  <!--  -->

  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="Content-Language" content="en">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <link rel="icon" href="../../favicon.png">
  <link href="https://unpkg.com/plume-css@1.0.13/lib/plume-all.css" rel="stylesheet" rel="preload" as="style" media="all" defer>
  <link rel="stylesheet" href="https://unpkg.com/1post@1.0.3/themes/default-dark.css">
  <link href="https://unpkg.com/prismjs@1.28.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
  
  <style>
    :root {
      --pm-paragraph-font-size: 1.2em
    }

    .plume .pm-link, .plume a {
      font-size: var(--pm-paragraph-font-size);
    }
  </style>
</head>
<body class="plume">
  <div class="pm-container">
    <h1>Frontend para Backenders | Conceitos necess√°rios</h1>

    <p>
      <a href="../..">‚Üê ‚Üê ‚Üê</a> &nbsp; 
      2/23/2023, 12:20:54 PM | <strong>Posted by:</strong>
      <a href="https://cvkeep.com/felipperegazio" target="_blank" rel="noreferrer noopener">Felippe Regazio</a>
    </p>

    <hr>

    

<p>Ao longo da minha carreira eu percebi que muitos backs n√£o sabem como o front moderno funciona, e isso gera v√°rios problemas de arquitetura e v√°rias tretas de escopo nos apps.</p>
<p>Ent√£o segue o que a Back PRECISA saber sobre o Front moderno:</p>
<h2 id="cors">CORS</h2>
<p>Essa √© sem d√∫vida uma dor. Ent√£o basicamente o que √© o CORS? Vamos a historia:</p>
<p>Antigamente qualquer client poderia requisitar qualquer recurso de qualquer domain...</p>
<p>Se eu criasse um site e colacasse nele imagens do seu site usando suas URLs, tudo certo. Vc meio que ia pagar servidor pra mim, eu ia consumir seus recursos. Barrar isso era complicado. Ent√£o o CORS foi criado pra evitar isso.</p>
<p>CORS quer dizer: Cross-Origin Resource Sharing (CORS) - Compartilhamento de Recurso de Dom√≠nio-Cruzado.</p>
<p>Basicamente ele delimita QUEM pode pedir o que para determinado server. Essa camada √© ativada em requests de um browser-client para um server.</p>
<p>Falando assim parece que isso √© problema do front n√©? Ent√£o: n√£o √©. Assim que o front mandar uma request para o server, isso vai acontecer:</p>
<p>O server vai ler a &quot;Origin&quot; e vai retornar uma header determinando quem pode ler aquele recurso, a: Access-Control-Allow-Origin.</p>
<p>Se o front n√£o estiver permitido ali a request √© barrada pelo BROWSER. N√£o h√° nada que um frontender possa fazer a n√£o ser pedir pro backender configurar corretamente as headers de CORS. E n√£o adianta testar no Postman pq de novo: √© o BROWSER que vai barrar.</p>
<p>Por padr√£o o CORS vem configurado como same-origin. Isso quer dizer que um dominio s√≥ pode pedir recurso para o mesmo dom√≠nio. Ou seja: site x carrega imagem de site x, se carregar de site Y: CORS Block!</p>
<p>Problema √© que hoje usamos APIs desacopladas que rodam em outros dom√≠nios. Quando o front X fizer request para a API Y, se a API Y n√£o configurou a Access-Control-Allow-Origin para esse Front, o browser vai barrar a request com CORS-Block. Cabe ao BACKEND configurar o CORS da API</p>
<h2 id="spapwa">SPA/PWA</h2>
<p>Antigamente toda vez que vc acessava uma pagina, uma request era feita para um servidor que retornava o conteudo dela para o browser desenhar o HTML e prover os recursos. Hoje isso n√£o funciona mais assim na maior parte das vezes.</p>
<p>SPA significa: Single Page Application. Isso significa que quando vc abrir um front o que ser√° carregado vai ser um Bundle JS todo fatiado. Aquilo √© basicamente a aplica√ß√£o inteira. √â quase como &quot;instalar&quot; um app no navegador. A partir da√≠ tudo √© carregado DINAMICAMENTE</p>
<p>Quando sua pagina for carregada no front, √© o front geralmente que vai:</p>
<ul>
<li><p>controlar as rotas (URLs e como elas mudam, o backe nem vai enxergar)</p>
</li>
<li><p>quase toda request para API ser√° dinamica via http-request e cross domain</p>
</li>
<li><p>se vc mudar de pagina o FRONT carrega ela</p>
</li>
</ul>
<p>Na pratica isso quer dizer que n√£o adianta o back fazer malabarismos de seguran√ßa, gateways, sess√µes m√°gicas que definem estado de login baseado em requests, redirects rebuscados pq: NAO VAI FUNCIONAR rs.</p>
<p>Cabe ainda citar que: http-requests s√£o stateless, o front s√≥ vai conhecer seu backend no momento da request, assim que a request terminar, seu backend n√£o sabe que o client existe nem vice-versa.</p>
<p>Se vc decidir INSTALAR mesmo essa aplica√ß√£o no browser, vc tem uma PWA: Progressive Web App. Ou aplica√ß√£o web progressiva, isso pq ela carrega toda a casca e vai pedindo recursos pro server PROGRESSIVAMENTE. Ou seja: o back tem pouca governan√ßa sobre o funcionamento do Front.</p>
<h2 id="üü®-bff">üü® BFF</h2>
<p>Com esse monte de regras pode ser que o front comece a se meter muito no backend e at√© a for√ßar certos modelos. Isso pode ser ruim, da√≠ que entra o &quot;Back For Front&quot;, uma camada backend criada exclusivamente pra fazer a ponte entre um Client e uma API complexa.</p>
<p>Em organiza√ß√µes mais complexas, com times de backends complexos e grandes um BFF salva muito o tempo dos fronts e d√° MUITA liberdade pra ambos os lados, bem como deixa o proprio front cuidar de aspectos de back inerentes ao Front. pra saber mais:</p>
<p><a href="https://felipperegazio.com/posts/vamos-falar-de-bff-pattern/" target="_blank">Vamos falar de BFF Pattern?</a></p>
<h2 id="üü®-urldominos-importam">üü® URL/DOMINOS IMPORTAM!</h2>
<p>Muitas vezes em requests de microservices para microservices, um domino ou URL √© um mero endpoint para um recurso, e n√£o dita nada mais que isso. (as vezes n√£o, mas geralmente URL pro back s√£o endpoints, n√£o s√£o contratos).</p>
<p>Para o front a URL √© um contrato. Ela √© atrelada a uma cacetada de pol√≠ticas e verifica√ß√µes:</p>
<p>CORS, CSP, Cookie Policies, Roteamento de SPAs, . Numa SPA ent√£o o Front ter√° pleno dom√≠nio da URL, historico e roteamento via Client mesmo.</p>
<p>Leve isso em conta, dependendo de onde um back coloca um recurso, se muda ele de lugar, ou se resolve enxer de parametros, queries, hashes, isso pode influenciar profundamente o front. Nada ali √© &quot;s√≥ mover do dominio X pro Y que quando o front bater vai dar no mesmo&quot;. N√£o vai rs.</p>
<h2 id="üü®-dado-vem-dado-volta-same-model">üü® Dado vem, dado volta (same model)</h2>
<p>N√£o importa como Forms s√£o constru√≠dos no front, uma coisa √© certa: Da mesma forma que eles vieram eles tem que voltar pra garantir uma boa UX e uma boa DX.</p>
<p>Isso deve-se a varios motivos estruturais que n√£o vou discorrer aqui, mas uma coisa deve ser feita:</p>
<p>Se um recurso √© editavel, o back deve procurar fechar um contrato com o front e n√£o fugir dessa estrutura. Ex: Vc vai fazer uma todo list com os seguintes endpoints</p>
<p>GET /items { <items> }</p>
<p>PUT /item { itemID, itemDescription }</p>
<p>Vc tem um endpoint que lista e um que insere um novo item. Logo vc teria o de editar, certo?</p>
<p>Para esses endpoints a estrutura de item deve ser sempre a MESMA. Todos os items retornados em /items devem ser:</p>
<p> { itemID, itemDescription }</p>
<p>O dado que vai via PUT?</p>
<p> { itemID, itemDescription }</p>
<p>O que vai pra editar?</p>
<p> { itemID, itemDescription }</p>
<p> O contrato pode ter campos decrementais (opcionais), mas n√£o deve mudar de estrutura. Se o contrato muda de acordo com a a√ß√£o nos endpoints para um mesmo recurso o front vai ter que fazer uma cacetada de malabarismo pra entender quando o user ta tomando cada a√ß√£o (criar, editar, etc) e mudar o modelo de acordo com isso: bugs a vista e complexidade desnecess√°ria.</p>
<h2 id="thats-all-folks">Thats all folks</h2>
<p>Importante ter em mente que o front virou um monstrinho, n√£o √© mais aquela coisa desarticulada e simplista. Pense numa aplica√ß√£o Front com basicamente a mesma (ou mais) complexidade que uma aplica√ß√£o desktop  rodando num SO chamado Browser.</p>


  </div>

  <!-- Prism Code Highlighting -->
  <script src="https://unpkg.com/prismjs@1.28.0/components/prism-core.min.js"></script>
  <script src="https://unpkg.com/prismjs@1.28.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>